---
title: Infinite Parallax Starfield
layout: post
---

<!-- 13 June 2011 -->
<p>
<a href="/img/hypernova/hypernova.png">
  <img src="/img/hypernova/hypernova-thumb.png" alt="" class="right"/>
</a>

In my free time I've been working on an unannounced line-art space
shooter game called Hypernova. It looks a little
like <i>Asteroids</i>, but the screen doesn't wrap around at
all. Space is infinite, and there will be all sorts of things going on
out there. Quests, loot, ship upgrades and enhancements, hirelings.
</p>
<p>
It will be using no bitmapped images. All the graphics are vector
images described by text files. I was originally intending to follow
the same path with sound effects, and rely mostly on MIDI. However, I
quickly found out that many computers have no MIDI support at all.
</p>
<p>
One of the early challenges was a nice starfield background. It has
several constraints:
</p>
<ul>
  <li>Can't use any bitmapped images.</li>
  <li>Must work over practically infinite space.</li>
  <li>I must be able to resize the display</li>
  <li>Must be fast.</li>
</ul>
<p>
And in addition, there are some unnecessary, but desirable,
properties,
</p>
<ul>
  <li>When leaving a particular location and returning, I'd like to
      see the same starfield pattern again.</li>
  <li>At the same time, I never want to see that same pattern at a
      different position.</li>
</ul>
<p>
When I was a kid I created the effect as a project, but it didn't have
the both the desired properties above. It's also the method I found
over and over when searching the Internet. There is an array of
stars. Star positions are translated as the camera moves. If a star
ever exits the display, replace it at a random position on the edge of
the screen. To create a parallax effect, each star's translation is
scaled by a unique random factor.
</p>
<p>
However, there's another algorithm I like much better, and it has both
the desirable properties. Space is broken up into a grid of square
tiles. To determine the star pattern in any given tile, hash the
tile's position, and use the hash output to generate a few positions
within the tiles, which is where stars are drawn. To create a parallax
effect, perform it in different layers at different scales.
</p>
<p>
Here's what it looks like in the game,
</p>
<p class="center">
  <img src="/img/hypernova/starfield.gif" alt=""/>
</p>
<p>
Hypernova is written in Java, with Clojure as a scripting language, so
the starfield drawing function looks like this.
</p>
<pre>
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable-name">STAR_SEED</span> = 0x9d2c5680;
<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable-name">STAR_TILE_SIZE</span> = 256;

<span class="keyword">public</span> <span class="type">void</span> <span class="function-name">drawStars</span>(<span class="type">Graphics2D</span> <span class="variable-name">g</span>, <span class="type">int</span> <span class="variable-name">xoff</span>, <span class="type">int</span> <span class="variable-name">yoff</span>, <span class="type">int</span> <span class="variable-name">starscale</span>) {
    <span class="type">int</span> <span class="variable-name">size</span> = STAR_TILE_SIZE / starscale;
    <span class="type">int</span> <span class="variable-name">w</span> = getWidth();
    <span class="type">int</span> <span class="variable-name">h</span> = getHeight();

    <span class="comment-delimiter">/* </span><span class="comment">Top-left tile's top-left position. */</span>
    <span class="type">int</span> <span class="variable-name">sx</span> = ((xoff - w/2) / size) * size - size;
    <span class="type">int</span> <span class="variable-name">sy</span> = ((yoff - h/2) / size) * size - size;

    <span class="comment-delimiter">/* </span><span class="comment">Draw each tile currently in view. */</span>
    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable-name">i</span> = sx; i &lt;= w + sx + size * 3; i += size) {
        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable-name">j</span> = sy; j &lt;= h + sy + size * 3; j += size) {
            <span class="type">int</span> <span class="variable-name">hash</span> = mix(STAR_SEED, i, j);
            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable-name">n</span> = 0; n &lt; 3; n++) {
                <span class="type">int</span> <span class="variable-name">px</span> = (hash % size) + (i - xoff);
                hash &gt;&gt;= 3;
                <span class="type">int</span> <span class="variable-name">py</span> = (hash % size) + (j - yoff);
                hash &gt;&gt;= 3;
                g.drawLine(px, py, px, py);
            }
        }
    }
}
</pre>
<p>
Assuming the origin is in the center of the display, it iterates over
each tile currently covered by the display. Positions are created by
looking at the first couple bits of the hash for X, shift a few off,
and looking at the first few bits again for Y. Repeat until we run out
of bits. It's called with different <code>starscale</code>s, back to
front (darker to lighter), to create layers.
</p>
<p>
The <code>STAR_SEED</code> is just a Mersenne prime from the Mersenne
Twister PRNG. It probably doesn't matter much what you choose for the
seed, but changing it by a single bit will drastically alter the
starfield.
</p>
<p>
As far as I know, Java comes with no decent 32-bit (int) hash
functions, which is really one of the biggest roadblocks in
implementing effective <code>hashCodes()</code>s. Fortunately, I found
an excellent hash function,
<a href="http://www.concentric.net/~ttwang/tech/inthash.htm">
Robert Jenkins' 96 bit Mix Function</a>, to do the trick.
</p>
<pre>
<span class="doc">/** Robert Jenkins' 96 bit Mix Function. */</span>
<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="function-name">mix</span>(<span class="type">int</span> <span class="variable-name">a</span>, <span class="type">int</span> <span class="variable-name">b</span>, <span class="type">int</span> <span class="variable-name">c</span>) {
    a=a-b;  a=a-c;  a=a^(c &gt;&gt;&gt; 13);
    b=b-c;  b=b-a;  b=b^(a &lt;&lt; 8);
    c=c-a;  c=c-b;  c=c^(b &gt;&gt;&gt; 13);
    a=a-b;  a=a-c;  a=a^(c &gt;&gt;&gt; 12);
    b=b-c;  b=b-a;  b=b^(a &lt;&lt; 16);
    c=c-a;  c=c-b;  c=c^(b &gt;&gt;&gt; 5);
    a=a-b;  a=a-c;  a=a^(c &gt;&gt;&gt; 3);
    b=b-c;  b=b-a;  b=b^(a &lt;&lt; 10);
    c=c-a;  c=c-b;  c=c^(b &gt;&gt;&gt; 15);
    <span class="keyword">return</span> c;
}
</pre>
