---
title: Arcfour and CipherSaber in Emacs Lisp
layout: post
---

<!-- 26 April 2009 -->
<p>
I have previously talked about <a href="/blog/2008/08/09"> arcfour</a>
and <a href="/blog/2009/04/24"> CipherSaber</a> and provided
implementations in C. For fun, I made an implementation of arcfour in
Emacs lisp (elisp), and built upon that to make a CipherSaber
implementation in elisp. Check it out with Git,
</p>
<pre>
git clone <a href="http://git.nullprogram.com/?p=arcfour.git;a=summary">http://git.nullprogram.com/arcfour.git</a>
</pre>
<p>
If you don't have Git (yet), you can follow that link to use the web
interface. The relevant files are <code>arcfour.el</code> and
<code>ciphersaber.el</code>. There are some test vectors in there that
I won't show here. Here is the arcfour implementation,
</p>
<pre>
(<span class="keyword">defun</span> <span class="function-name">rc4-init-state</span> ()
  <span class="string">"Initialize the arcfour state vector."</span>
  (interactive)
  (setq rc4-state (make-vector 256 0))
  (setq rc4-i 0)
  (setq rc4-j 0)
  (<span class="keyword">let</span> (i)
    (<span class="keyword">dotimes</span> (i 256 rc4-state)
      (aset rc4-state i i))))

(<span class="keyword">defun</span> <span class="function-name">rc4-swap</span> (i j)
  <span class="string">"Swap two elements in the state vector."</span>
  (<span class="keyword">let</span> ((temp (aref rc4-state i)))
    (aset rc4-state i (aref rc4-state j))
    (aset rc4-state j temp)))

(<span class="keyword">defun</span> <span class="function-name">rc4-key-sched</span> (key)
  <span class="string">"Arcfour key-scheduler: initialize state from key."</span>
  (interactive <span class="string">"sEnter key: "</span>)
  (<span class="keyword">let</span> ((j 0) i)
    (<span class="keyword">dotimes</span> (i 256 rc4-state)
      (setq j (% (+ j
                    (aref rc4-state i)
                    (aref key (% i (length key)))) 256))
      (rc4-swap i j))))

(<span class="keyword">defun</span> <span class="function-name">rc4-gen-byte</span> ()
  <span class="string">"Generate a single byte."</span>
  (interactive)
  (setq rc4-i (% (1+ rc4-i) 256))
  (setq rc4-j (% (+ rc4-j (aref rc4-state rc4-i)) 256))
  (rc4-swap rc4-i rc4-j)
  (aref rc4-state (% (+ (aref rc4-state rc4-i)
                        (aref rc4-state rc4-j)) 256)))
</pre>
<p>
For the sake of simplicity it uses some global variables to store the
cipher state. It would be better if the state was returned as a list,
continuation, or closure. That way we could run a bunch of different
ciphers at the same time.
</p>
<p>
And this provides interactive functions so that they can be called by
a user right on the buffer being used, with <code>M-x rc4-buffer</code>.
</p>
<pre>
(<span class="keyword">defun</span> <span class="function-name">rc4-region</span> (start end key)
  <span class="string">"Encrypt/decrypt region with arcfour using given key."</span>
  (interactive <span class="string">"r\nsEnter key: "</span>)
  (rc4-init-state)
  (rc4-key-sched key)
  (<span class="keyword">save-excursion</span>
    (<span class="keyword">let</span> (c)
      (goto-char start)
      (<span class="keyword">while</span> (&lt; (point) end)
        (setq c (char-after))
        (delete-char 1)
        (insert-char (logxor c (rc4-gen-byte)) 1)))))

(<span class="keyword">defun</span> <span class="function-name">rc4-buffer</span> (key)
  <span class="string">"Encrypt/decrypt entire buffer with arcfour."</span>
  (interactive <span class="string">"sEnter key: "</span>)
  (rc4-region (point-min) (point-max) key))
</pre>
<p>
You may run into encoding issues with encrypted regions. The
CipherSaber implementation below gets around this problem by turning
off multi-byte encoding with <code>set-buffer-multibyte</code>.
</p>
<p>
In <code>ciphersaber.el</code> we apply these functions.  The
CipherSaber functions can be called with <code>M-x
cs-encrypt-buffer</code> and <code>M-x cs-decrypt-buffer</code>. Note
that this is only CipherSaber-1, and I leave CipherSaber-2 as an
exercise for the reader :-P.
</p>
<pre>
(<span class="keyword">defun</span> <span class="function-name">cs-encrypt-buffer</span> (key)
  <span class="string">"Encrypt buffer with CipherSaber-1."</span>
  (interactive <span class="string">"sEnter key: "</span>)
  (set-buffer-multibyte nil)
  (<span class="keyword">let*</span> ((iv (cs-generate-iv))
         (cs-key (concat key iv)))
    (rc4-buffer cs-key)
    (beginning-of-buffer)
    (insert iv)))

(<span class="keyword">defun</span> <span class="function-name">cs-decrypt-buffer</span> (key)
  <span class="string">"Decrypt buffer with CipherSaber-1."</span>
  (interactive <span class="string">"sEnter key: "</span>)
  (<span class="keyword">let*</span> ((iv (cs-retrieve-iv))
         (cs-key (concat key iv)))
    (rc4-buffer cs-key)))

(<span class="keyword">defun</span> <span class="function-name">cs-generate-iv</span> ()
  <span class="string">"Generate a 10-byte initialization vector."</span>
  (<span class="keyword">let</span> ((iv <span class="string">""</span>) i)
    (<span class="keyword">dotimes</span> (i 10 iv)
      (setq iv (concat iv (char-to-string (random 256)))))))

(<span class="keyword">defun</span> <span class="function-name">cs-retrieve-iv</span> ()
  <span class="string">"Remove initialization vector from buffer and return it."</span>
  (beginning-of-buffer)
  (<span class="keyword">let</span> ((iv <span class="string">""</span>) i)
    (<span class="keyword">dotimes</span> (i 10 iv)
      (setq iv (concat iv (char-to-string (char-after))))
      (delete-char 1))))
</pre>
<p>
I didn't bother with <code>save-excursion</code> because I didn't
think it would be important where the point is in the middle of an
encrypted file. Feel free to add it, though!
</p>
<p>
These functions could be used to make a minor mode to transparently
encrypt and decrypt CipherSaber files. It could also be modified to
take advantage of Emacs' <i>batch</i> mode to handle CipherSaber
processing right from the shell. But those are other projects!
</p>
